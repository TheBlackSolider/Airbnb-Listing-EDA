# -*- coding: utf-8 -*-
"""revised code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nA8QJ9CC14oQB4dotqYWzuzO88DVjb93
"""

# Importing necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.manifold import TSNE
from sklearn.preprocessing import StandardScaler

# Reading the dataset
df = pd.read_csv('/content/listings (2).csv')

# Displaying basic information about the dataset
print("Dataset information:")
print(df.info())

# Displaying the first few rows of the dataset
print("\nFirst few rows of the dataset:")
print(df.head())

# Displaying the last few rows of the dataset
print("\nLast few rows of the dataset:")
print(df.tail(10))

# Checking the shape of the dataset
print("\nDataset shape:")
print(df.shape)

# Displaying the columns of the dataset
print("\nColumns of the dataset:")
print(df.columns)

# Descriptive statistics of numerical columns
print("\nDescriptive statistics of numerical columns:")
print(df.describe())

# Descriptive statistics of categorical columns
print("\nDescriptive statistics of categorical columns:")
print(df.describe(include=['object', 'bool']))

# Checking for missing values
print("\nNumber of missing values in each column:")
print(df.isnull().sum())

# Checking data types of columns
print("\nData types of columns:")
print(df.dtypes)

# Handling missing values: Imputing numerical columns with mean and categorical columns with mode
for col in df.select_dtypes(include=[np.number]):
    df[col] = df[col].fillna(df[col].mean())

for col in df.select_dtypes(include=[object]):
    df[col] = df[col].fillna(df[col].mode().iloc[0])

# Displaying the dataset after handling missing values
print("\nDataFrame after handling missing values:")
print(df)

# Displaying the summary statistics of 'room_type' grouped by 'price' and 'number_of_reviews'
print("\nSummary statistics of 'room_type' grouped by 'price' and 'number_of_reviews':")
print(df.groupby(['room_type'])[['price', 'number_of_reviews']].describe())

# Dropping the 'neighbourhood_group' column
df = df.drop('neighbourhood_group', axis=1)

# Crosstab between 'room_type' and 'availability_365'
print("\nCross-tabulation between 'room_type' and 'availability_365':")
print(pd.crosstab(df['room_type'], df['availability_365']))

# Plotting a count plot of 'room_type' with 'number_of_reviews'
plt.figure(figsize=(10, 5))
sns.countplot(x="room_type", hue="number_of_reviews", data=df)
plt.title('Count of Room Types with Number of Reviews')
plt.xlabel('Room Type')
plt.ylabel('Count')
plt.show()

# Histogram and density plots for 'room_type' and 'number_of_reviews'
print("\nHistogram and Density plots for 'room_type' and 'number_of_reviews':")
features = ['room_type', 'number_of_reviews']
df[features].hist(figsize=(10, 5))
plt.tight_layout()
plt.show()

df[features].plot(kind='density', subplots=True, layout=(1, 2), sharex=False)
plt.tight_layout()
plt.show()

# Distribution plot for 'price'
plt.figure(figsize=(8, 5))
sns.distplot(df['price'])
plt.title('Distribution of Price')
plt.xlabel('Price')
plt.ylabel('Density')
plt.show()

# Boxplot for 'price', 'room_type', and 'number_of_reviews'
plt.figure(figsize=(12, 5))
plt.subplot(1, 3, 1)
sns.boxplot(df['price'])
plt.title('Boxplot of Price')

plt.subplot(1, 3, 2)
sns.boxplot(df['room_type'])
plt.title('Boxplot of Room Type')

plt.subplot(1, 3, 3)
sns.boxplot(df['number_of_reviews'])
plt.title('Boxplot of Number of Reviews')

plt.tight_layout()
plt.show()

# Violin plots for 'price', 'room_type', and 'number_of_reviews'
plt.figure(figsize=(12, 5))
plt.subplot(1, 3, 1)
sns.violinplot(df['price'])
plt.title('Violin Plot of Price')

plt.subplot(1, 3, 2)
sns.violinplot(df['room_type'])
plt.title('Violin Plot of Room Type')

plt.subplot(1, 3, 3)
sns.violinplot(df['number_of_reviews'])
plt.title('Violin Plot of Number of Reviews')

plt.tight_layout()
plt.show()

# Summary statistics of 'room_type' and value counts of 'price', 'room_type', and 'number_of_reviews'
print("\nSummary statistics and value counts of 'price', 'room_type', and 'number_of_reviews':")
print(df[features].describe())
print("\nValue counts of 'price':")
print(df['price'].value_counts())
print("\nValue counts of 'room_type':")
print(df['room_type'].value_counts())
print("\nValue counts of 'number_of_reviews':")
print(df['number_of_reviews'].value_counts())

# Plotting pair plots and LM plots for selected features
sns.pairplot(df[selected_features])
plt.title('Pair Plot of Selected Features')
plt.show()

sns.lmplot(x='number_of_reviews', y='price', data=df, hue='number_of_reviews', fit_reg=False)
plt.title('LM Plot of Number of Reviews vs Price')
plt.show()

# Boxplot and violin plot for 'price' vs 'number_of_reviews' and 'price' vs 'minimum_nights'
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.boxplot(x='price', y='number_of_reviews', data=df)
plt.title('Boxplot of Price vs Number of Reviews')

plt.subplot(1, 2, 2)
sns.violinplot(x='price', y='minimum_nights', data=df)
plt.title('Violin Plot of Price vs Minimum Nights')

plt.tight_layout()
plt.show()

# Cross-tabulation of 'minimum_nights' and 'number_of_reviews' and mean calculation
print("\nCross-tabulation of 'minimum_nights' and 'number_of_reviews' and mean calculation:")
print(pd.crosstab(df['minimum_nights'], df['number_of_reviews']).T)
print("\nMean of 'number_of_reviews' grouped by 'minimum_nights':")
print(df.groupby(['minimum_nights'])['number_of_reviews'].agg([np.mean]).sort_values(by='mean', ascending=False))

# Performing t-SNE for visualization of high-dimensional data
x = df.drop(['name', 'host_name', 'neighbourhood', 'license', 'room_type', 'last_review'], axis=1)
x_scl = StandardScaler().fit_transform(x)
tsne = TSNE()
x_red = tsne.fit_transform(x_scl)

# Plotting the t-SNE plot
plt.figure(figsize=(10, 5))
plt.scatter(x_red[:, 0], x_red[:, 1], alpha=0.5)
plt.title('t-SNE Plot of Listing Features')
plt.xlabel('t-SNE Dimension 1')
plt.ylabel('t-SNE Dimension 2')
plt.show()

# Insight:
# The t-SNE plot shows the distribution of listing features in a lower-dimensional space.

# Decision for Stakeholders:
# Stakeholders could use the t-SNE plot to explore potential clusters or patterns in the data.

# Conclusion:
# The analysis provides valuable insights into the Airbnb market, including pricing trends, availability patterns,
# and the impact of room types on demand. Stakeholders can use these insights to optimize their listings and maximize profitability.

